<!DOCTYPE html>
<html lang="nl">
<head>
<meta charset="UTF-8">
<title>Habbo Clone</title>
<style>
html, body {
  margin: 0;
  padding: 0;
  overflow: hidden;
  background: #222;
}

canvas {
  display: block;
  cursor: pointer;
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
/* Algemene knoppen */
/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
button {
  font-family: Arial, sans-serif;
  cursor: pointer;
  border: none;
  border-radius: 6px;
  padding: 5px 12px;
  color: #fff;
}

/* Zoom knoppen */
#zoomIn {
  position: absolute;
  top: 10px;
  left: 10px;
  background: #28a745;
}
#zoomOut {
  position: absolute;
  top: 10px;
  left: 60px;
  background: #dc3545;
}
#centerCam {
  position: absolute;
  top: 10px;
  left: 110px;
  background: #007bff;
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
/* Footer / chat input */
/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
#footer {
  position: absolute;
  bottom: 0;
  left: 0;
  width: 100%;
  height: 50px;
  background: rgba(0, 0, 0, 0.85);
  display: flex;
  align-items: center;
  justify-content: center; /* Centreer de chat-groep */
  padding: 0 20px; /* Wat ruimte aan de zijkanten */
  box-sizing: border-box;
}

.footer-left, .footer-right {
  position: absolute;
  top: 50%;
  transform: translateY(-50%);
  display: flex;
  gap: 10px;
  width: 250px; /* Vaste breedte om de chat-input niet te verstoren */
}

.footer-left { left: 20px; }
.footer-right { right: 20px; justify-content: flex-end; }

#chatInput {
  width: 300px;
  padding: 6px;
  font-size: 14px;
  border-radius: 24px;
  border: none;
  outline: none;
}

#charCounter {
  color: #aaa;
  font-size: 12px;
  font-family: Arial, sans-serif;
  min-width: 60px;
  text-align: left;
}

/* Nieuwe container voor de hele chat-groep */
.chat-group {
    display: flex;
    align-items: center;
    gap: 10px;
}

#openChatLog {
  background: #444;
  height: 32px;
  padding: 0 10px;
  font-size: 14px;
  border-radius: 6px;
  cursor: pointer;
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
/* Bouwmenu */
/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
#buildMenu {
  position: absolute; /* Nodig voor verplaatsen */
  left: 40px;
  top: 80px;
  /* 60px voor categorieÃ«n + 450px voor content */
  width: 510px;
  height: 470px; /* Iets hoger gemaakt voor de color picker */
  background: rgba(17, 17, 17, 0.85);
  border: 1px solid rgba(255, 255, 255, 0.85);
  border-radius: 10px;
  display: none; /* Start verborgen, wordt 'flex' in JS */
  z-index: 20;
  overflow: hidden; /* Zorgt dat content binnen de afgeronde hoeken blijft */
  flex-direction: row; /* CategorieÃ«n links, content rechts */
}

#buildCategoryMenu {
  width: 60px;
  height: 100%;
  background: rgba(0, 0, 0, 0.2);
  border-right: 1px solid rgba(255, 255, 255, 0.2);
  padding: 10px;
  box-sizing: border-box;
  display: flex;
  flex-direction: column;
  gap: 10px;
  align-items: center; /* Centreer items voor vierkante knoppen */
}

.category-btn {
  width: 100%;
  height: 40px;
  background: #333;
  border: 2px solid #555;
  border-radius: 4px;
  font-size: 20px;
  display: flex;
  align-items: center;
  justify-content: center;
}

.category-btn.selected {
  border-color: white;
}

#buildMainContent {
  width: 450px;
}

#objectCategoryView {
  display: flex; /* Standaard zichtbaar */
  flex-direction: column;
  height: 100%;
}

#colorCategoryView {
  display: none; /* Standaard verborgen */
  box-sizing: border-box;
  height: calc(100% - 36px); /* Volledige hoogte minus de header */
  display: flex;
  flex-direction: row;
}

#objectSubCategoryMenu {
  display: flex;
  flex-direction: column;
  gap: 10px;
  width: 60px;
  height: 100%;
  background: rgba(0, 0, 0, 0.2);
  border-right: 1px solid rgba(255, 255, 255, 0.2);
  padding: 10px;
  box-sizing: border-box;
}


#colorTools {
  display: flex;
  flex-direction: column;
  gap: 10px;
  width: 60px;
  height: 100%;
  background: rgba(0, 0, 0, 0.2);
  border-right: 1px solid rgba(255, 255, 255, 0.2);
  padding: 10px;
  box-sizing: border-box;
}

#colorPickerWrapper {
  flex-grow: 1;
  padding: 10px;
  display: flex;
  flex-direction: column; /* Zorgt ervoor dat de color picker en details onder elkaar staan */
  justify-content: center;
  align-items: center;
}

#colorPicker {
  width: 100%;
  height: 100%;
  cursor: pointer;
  -webkit-color-swatch-wrapper { padding: 0; } /* Webkit specifieke styling */
  border: none;
  background: none;
}

#colorDetails {
  display: flex;
  align-items: center;
  gap: 10px;
  margin-top: 10px;
}

#colorPreview {
  width: 40px;
  height: 40px;
  border: 1px solid #fff;
  border-radius: 4px;
}

#hexInput {
  width: 100px;
  padding: 8px;
  background: #222;
  border: 1px solid #555;
  border-radius: 4px;
  color: #fff;
  font-family: monospace;
  font-size: 14px;
}

#buildTools {
  padding: 5px 10px; /* Minder verticale padding */
  /* border-top is nu border-bottom op de header */
  display: flex;
  gap: 10px;
  justify-content: flex-end; /* Lijn knoppen rechts uit */
  background: rgba(0,0,0,0.1); /* Lichte achtergrond voor contrast */
  border-bottom: 1px solid rgba(255, 255, 255, 0.2); /* Scheidingslijn */
}

.tool-btn {
  width: 40px; /* Vaste breedte */
  height: 40px; /* Vaste hoogte */
  padding: 0; /* Geen extra padding */
  background: #333;
  border: 2px solid #555;
  color: white;
  cursor: pointer;
  border-radius: 4px;
  font-size: 20px; /* Grotere emoji */
  display: flex;
  align-items: center;
  justify-content: center;
}

.tool-btn.selected {
  background: #007bff;
  border-color: white;
}

#buildMenuHeader {
  height: 36px;
  line-height: 36px;
  padding: 0 12px;
  background: #1a1a1a;
  border-radius: 10px 10px 0 0;
  cursor: move;
  border-bottom: 1px solid rgba(255, 255, 255, 0.2); /* Scheidingslijn */
  user-select: none;
  color: white;
  font-family: Arial, sans-serif;
  font-size: 14px;
}

#buildMenuContent {
  display: grid;
  grid-template-columns: repeat(3, 1fr); /* Forceer 3 kolommen die de ruimte vullen */
  gap: 10px;
  padding: 10px; /* Padding voor de content zelf */
  height: calc(100% - 51px); /* Hoogte minus de dunnere #buildTools balk (50px + 1px border) */
  overflow-y: auto;
  box-sizing: border-box;
  justify-items: center; /* Centreer items binnen hun grid cel */
  align-items: start; /* Items bovenaan beginnen in hun cell */
}

.build-item {
  background: rgba(0, 0, 0, 0.4); /* Donkerder met transparantie */
  padding: 10px;
  border-radius: 6px;
  cursor: pointer;
  border: 2px solid transparent;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: space-between; /* Plaatje boven, tekst onder */
  gap: 8px;
  color: white;
  font-size: 12px;
  font-family: Arial, sans-serif; /* Consistent lettertype */
  width: 90px;
  height: 110px; /* Vaste hoogte teruggezet */
}


.build-item:hover {
  background: #555;
}

.build-item.selected {
  border-color: white;
}

#buildMenuHeader, #chatLogHeader, #inventoryHeader {
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.close-btn {
  font-size: 24px;
  font-weight: bold;
  line-height: 1;
  cursor: pointer;
  padding: 0 5px;
}

.build-item img {
  height: 64px; /* Vaste hoogte voor consistentie */
}

#chatLog {
  position: absolute;
  bottom: 60px;
  right: 20px;
  width: 320px;
  height: 400px;

  background: rgba(17, 17, 17, 0.85); /* Transparantie toegevoegd */
  color: white;
  border: 1px solid rgba(255, 255, 255, 0.85); /* Transparantie toegevoegd */
  border-radius: 10px;

  font-family: Arial;
  font-size: 14px;

  display: none;
  overflow: hidden;
  z-index: 20;
}

#inventory {
  position: absolute;
  left: 150px;
  top: 120px;
  width: 400px; /* Breder gemaakt */
  height: 450px; /* Langer gemaakt */
  background: rgba(17, 17, 17, 0.85); /* Transparantie toegevoegd */
  color: white;
  border: 1px solid rgba(255, 255, 255, 0.85); /* Transparantie toegevoegd */
  border-radius: 10px;
  font-family: Arial, sans-serif;
  font-size: 14px;
  display: none; /* Start verborgen */
  overflow: hidden;
  z-index: 20;
  flex-direction: column; /* Zorgt dat header en content onder elkaar staan */
}

#chatLogHeader {
  height: 36px;
  line-height: 36px;
  padding: 0 12px;

  background: #1a1a1a;
  border-bottom: 0px solid white;
  border-radius: 10px 10px 0 0;

  cursor: move;
  user-select: none;
}

#inventoryHeader {
  height: 36px;
  line-height: 36px;
  padding: 0 12px;
  background: #1a1a1a;
  border-bottom: 1px solid rgba(255, 255, 255, 0.2);
  border-radius: 10px 10px 0 0;
  cursor: move;
  user-select: none;
}

#inventoryTools {
  padding: 5px 10px; /* Minder verticale padding */
  display: flex;
  gap: 10px;
  justify-content: space-between; /* Wallet links, dagboek rechts */
  align-items: center; /* Verticaal centreren */
  background: rgba(0,0,0,0.1);
  border-bottom: 1px solid rgba(255, 255, 255, 0.2);
}

#wallet {
  font-family: Arial, sans-serif;
  font-size: 14px;
  color: white; /* Goud-achtige kleur */
  padding: 5px 10px;
  border-radius: 5px;
}

#chatLogContent {
  height: calc(100% - 36px);
  padding: 10px;
  overflow-y: auto;
  box-sizing: border-box;
}

#inventoryContent {
  height: calc(100% - 36px - 51px); /* Hoogte minus header en dunnere tools paneel */
  padding: 10px;
  overflow-y: auto;
  box-sizing: border-box;
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(90px, 1fr));
  gap: 10px;
  justify-items: center;
}

/* â”€â”€â”€â”€â”€ Custom scrollbar (WebKit) voor Chat & Bouwmenu â”€â”€â”€â”€â”€ */
#chatLogContent::-webkit-scrollbar,
#buildMenuContent::-webkit-scrollbar,
#inventoryContent::-webkit-scrollbar {
  width: 6px;
}

#chatLogContent::-webkit-scrollbar-track,
#buildMenuContent::-webkit-scrollbar-track,
#inventoryContent::-webkit-scrollbar-track {
  background: transparent;
}

#chatLogContent::-webkit-scrollbar-thumb,
#buildMenuContent::-webkit-scrollbar-thumb,
#inventoryContent::-webkit-scrollbar-thumb {
  background: white;
  border-radius: 6px;
}

/* â”€â”€â”€â”€â”€ Custom scrollbar (Firefox) voor Chat & Bouwmenu â”€â”€â”€â”€â”€ */
#chatLogContent,
#buildMenuContent,
#inventoryContent {
  scrollbar-width: thin;
  scrollbar-color: white transparent;
}

</style>
</head>
<body>

<script src="https://cdn.jsdelivr.net/npm/@jaames/iro@5"></script>

<button id="zoomIn">+</button>
<button id="zoomOut">-</button>
<button id="centerCam">Center</button>

<div id="footer">

  <div class="footer-left">
    <button id="buildBtn">Bouwen</button>
    <button id="inventoryBtn">Inventaris</button>
  </div>

  <div class="chat-group">
    <input id="chatInput" type="text" placeholder="Typ hier je bericht..." />
    <div id="charCounter">0 / 80</div>
  </div>

  <div class="footer-right">
    <button id="openChatLog">Open Chat</button>
  </div>

</div>

<div id="buildMenu" style="display: none;">
  <div id="buildCategoryMenu">
    <button class="category-btn selected" data-category="objecten" title="Objecten">ğŸ“¦</button>
    <button class="category-btn" data-category="kleur" title="Kleur">ğŸ¨</button>
  </div>

  <div id="buildMainContent">
    <div id="buildMenuHeader"> 
        <span>Bouwmodus</span> 
        <span class="close-btn" id="closeBuildMenuBtn">Ã—</span>
    </div>

    <!-- Weergave voor Objecten Categorie -->
    <div id="objectCategoryView" style="flex-direction: row;"> <!-- Aangepast voor sub-categorie menu -->
      <div id="objectSubCategoryMenu">
        <!-- Sub-categorie knoppen worden hier dynamisch toegevoegd -->
      </div>
      <div style="width: 100%; height: 100%;"> <!-- Wrapper voor tools en content -->
        <div id="buildTools">
          <button id="moveToolBtn" class="tool-btn" title="Verplaatsen">â†”ï¸</button>
          <button id="deleteToolBtn" class="tool-btn" title="Verwijderen">ğŸ—‘ï¸</button>
        </div>
        <div id="buildMenuContent">
          <!-- Items worden hier dynamisch toegevoegd -->
        </div>
      </div>
    </div>

    <!-- Weergave voor Kleur Categorie -->
    <div id="colorCategoryView">
      <div id="colorTools">
        <button class="tool-btn selected" data-tool="brush" title="Kwast">ğŸ–Œï¸</button> 
        <button class="tool-btn" data-tool="bucket" title="Verfemmer">ğŸª£</button>
      </div>
      <div id="colorPickerWrapper">
        <div id="color-picker-container"></div>
        <div id="colorDetails">
          <div id="colorPreview"></div>
          <input type="text" id="hexInput" maxlength="7">
        </div>
      </div>
    </div>
  </div>
</div>

<div id="chatLog">
  <div id="chatLogHeader">
    <span>Chat geschiedenis</span>
    <span class="close-btn" id="closeChatLogBtn">Ã—</span>
  </div>
  <div id="chatLogContent"></div>
</div>

<div id="inventory" style="display: none;">
  <div id="inventoryHeader">
    <span>Inventaris</span>
    <span class="close-btn" id="closeInventoryBtn">Ã—</span>
  </div>
  <div id="inventoryTools">
    <div id="wallet">â‚¬0.00</div>
    <button id="diaryBtn" class="tool-btn" title="Dagboek">ğŸ““</button>
  </div>
  <div id="inventoryContent">
    <!-- Inventaris items komen hier -->
  </div>
</div>

<canvas id="canvas"></canvas>

<script>
(function() { // Start van de IIFE
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

const MAX_CHARS = 80;
const charCounter = document.getElementById("charCounter");

const tileW = 64;
const tileH = 32;
const mapW = 25;
const mapH = 25;

// Snelheid speler FPS Hz
let lastTime = performance.now();

// Speler
const ball = { x:0.5, y:0.5 };
let hopOffset = 0;

// Jump variables
let jumpProgress = 0;
let jumping = false;
let jumpStart = {x:0, y:0};
let jumpEnd = {x:0, y:0};
const jumpHeight = 12;

// Hover
let hoverCell = null;

// Click-to-walk
let path = [];
let highlightedPath = []; // Voor het tekenen van het volledige pad

// Snelheid
const speed = 0.10;

// Zoom
const zoomLevels = [0.8, 0.9, 1.0, 1.2, 1.4]; // Fijnere zoom-stappen
let currentZoomIndex = 2; // Start op neutraal niveau (1.0)
let scale = zoomLevels[currentZoomIndex];

// Camera
let camX = 0; 
let camY = 0;

// Drag-camera
let isCameraDragging = false; // Nieuwe variabele voor camera slepen
let isObjectDragging = false; // Nieuwe variabele voor object slepen
let isItemDragging = false;   // NIEUW: Variabele voor het slepen van items
let dragStart = {x:0, y:0};
let camStart = {x:0, y:0};
const maxTiles = 4;

// Smooth center
let camTargetX = 0;
let camTargetY = 0;
let camSmooth = false;

// Bouwmodus
let highestZ = 21; // Startwaarde voor z-index management

function bringToFront(element) {
    // Reset z-index van alle vensters naar een basiswaarde
    document.getElementById('buildMenu').style.zIndex = 20;
    document.getElementById('chatLog').style.zIndex = 20;
    document.getElementById('inventory').style.zIndex = 20;
    // Plaats het geklikte element op de voorgrond
    element.style.zIndex = highestZ;
}

function closeSecondaryWindows() {
    document.getElementById('chatLog').style.display = 'none';
    document.getElementById('inventory').style.display = 'none';
}

function closeAllWindows() {
    closeSecondaryWindows();
    if (isBuildMode) {
        // Gebruik de bestaande klik-logica om de bouwmodus correct af te sluiten en op te ruimen
        buildBtn.click();
    }
}

let isBuildMode = false;
let selectedBuildObject = null;
let isBuildObjectFlipped = false; // Voor het spiegelen van objecten
let buildTool = 'place'; // 'place', 'move', 'delete'
let movingObject = null; // Object dat wordt verplaatst

let selectedColor = '#ff0000'; // Default kleur
let windowStatesBeforeDrag = null; // Onthoudt welke vensters open waren
let draggedObject = null; // Voor het verslepen van 'moveable' objecten buiten bouwmodus
let draggedItem = null; // NIEUW: Item dat wordt versleept
let draggedItemOriginalPos = null; // NIEUW: Originele positie van het versleepte item
let draggedObjectOriginalPos = null;
let camOriginalPos = null; // Voor het resetten van de camera na het slepen van een object

let activeObjectSubCategory = 'blok'; // Start met 'blok' geselecteerd
let activeBuildCategory = 'objecten'; // 'objecten', 'kleur', etc.
let colorTool = 'brush'; // 'brush', 'bucket'

let tileColors = {}; // Slaat de aangepaste tegelkleuren op
let wallColors = {}; // Slaat de muurkleuren op per segment, bv: { 'top_5': '#ff0000' }
let wallObjects = []; // Slaat geplaatste muurobjecten op, bv: { wallId: 'top_5', name: 'Muurdecoratie', flipped: false }

let hoverTarget = null; // Houdt bij wat er gehoverd wordt: { type: 'tile'/'wall', id: 'x,y'/'top'/'left' }

// Object image
const objectImg = new Image();
objectImg.src = "object_template.png"; // 64x64 symmetrisch
const objectImg96 = new Image();
objectImg96.src = "object_template_96.png"; // 64x96 symmetrisch
const moveableObjectImg = new Image();
moveableObjectImg.src = "object_moveable_template.png";
const wallItemImg = new Image();
wallItemImg.src = "wall_template.png";

// Nieuwe afbeelding voor oppakbare items
const itemImg = new Image();
itemImg.src = "item_block.png"; // Zorg ervoor dat dit bestand bestaat

// Array voor oppakbare items
const items = [
    { x: 8.5, y: 8.5, vx: 0, vy: 0, mass: 1.2, image: itemImg },
    { x: 12.5, y: 15.5, vx: 0, vy: 0, mass: 1.0, image: itemImg }
];

// Array voor items in de inventaris
const inventoryItems = [];

// Objecten array
const objects = [
    { x: 5, y: 5, height: 1, flipped: false, name: "Blok" },   // Normaal object
    { x: 10, y: 10, height: 2, flipped: false, name: "Hoge Blok" }, // Hoog object
    // Extra willekeurige objecten voor testdoeleinden
    { x: 15, y: 8, height: 1, flipped: false, name: "Blok" },
    { x: 3, y: 18, height: 2, flipped: true, name: "Hoge Blok" }, // Test een geflipt object
    { x: 20, y: 20, height: 1, flipped: false, name: "Blok" },
    { x: 18, y: 3, height: 2, flipped: false, name: "Hoge Blok" },
    { x: 8, y: 12, height: 1, flipped: false, moveable: true, name: "Verplaatsbaar Blok" } // Nieuw verplaatsbaar object
];

// Helper: geef de tiles van de "achterliggende driehoek" van een object
function getTriangleBehind(obj) {
    const x = Math.floor(obj.x);
    const y = Math.floor(obj.y);

    return [
        {x: x,     y: y + 1},   // direct achter
        {x: x - 1, y: y + 1},   // links achter
        {x: x + 1, y: y + 1}    // rechts achter
    ];
}

function renderInventoryItems() {
    const inventoryContent = document.getElementById('inventoryContent');
    inventoryContent.innerHTML = ''; // Maak de lijst leeg

    inventoryItems.forEach(item => {
        const div = document.createElement("div"); // NIEUW: Gebruik item.name voor weergave
        div.className = "build-item"; // Gebruik dezelfde stijl als bouw-items
        div.innerHTML = `<img src="${item.image.src}" alt="Item"><span>Oppakbaar</span>`;
        // Hier kun je eventueel een onclick toevoegen om het item terug te plaatsen
        inventoryContent.appendChild(div);
    });
}

inventoryBtn.addEventListener("click", () => {
    const inventory = document.getElementById('inventory');
    inventory.style.display = inventory.style.display === 'flex' ? 'none' : 'flex';
    renderInventoryItems(); // Update de inventaris wanneer deze wordt geopend
});

// Collision check
function isBlocked(x, y) {
    // Player kan niet op object tile staan
    return objects.some(o => o.x === x && o.y === y);
}

// NIEUW: Check of een tegel bezet is door een item (exclusief het item dat we nu slepen)
function isItemOccupied(x, y) {
    return items.some(item => item !== draggedItem && Math.floor(item.x) === x && Math.floor(item.y) === y);
}

// Bouwmodus logica
const buildBtn = document.getElementById("buildBtn");
const buildMenu = document.getElementById("buildMenu");
const buildCategoryMenu = document.getElementById("buildCategoryMenu");
const buildMenuContent = document.getElementById("buildMenuContent");



const buildableObjects = [
    { name: "Blok", height: 1, image: objectImg.src, category: 'objecten', subCategory: 'blok', placement: 'floor' },
    { name: "Hoge Blok", height: 2, image: objectImg96.src, category: 'objecten', subCategory: 'blok', placement: 'floor' },
    { name: "Verplaatsbaar Blok", height: 1, image: moveableObjectImg.src, category: 'objecten', subCategory: 'blok', placement: 'floor', moveable: true },
    ...Array(6).fill(null).map((_, i) => ({ name: `Test ${i+1}`, height: 1, image: "", category: 'objecten', subCategory: 'blok', placement: 'floor' })),
    { name: "Muurdecoratie", image: wallItemImg.src, category: 'objecten', subCategory: 'muur', placement: 'wall' },
    ...Array(8).fill(null).map((_, i) => ({ name: `Test Muur ${i+1}`, image: "", category: 'objecten', subCategory: 'muur', placement: 'wall' }))
];

function renderBuildItems() {
    const moveToolBtn = document.getElementById("moveToolBtn");
    const deleteToolBtn = document.getElementById("deleteToolBtn");

    buildMenuContent.innerHTML = ''; // Maak de lijst leeg
    const itemsToShow = buildableObjects.filter(item => 
        item.category === activeBuildCategory && item.subCategory === activeObjectSubCategory
    );

    itemsToShow.forEach(item => {
    const div = document.createElement("div");
    div.className = "build-item";
    div.innerHTML = `<img src="${item.image}" alt="${item.name}">${item.name}`;
    div.onclick = () => {
        // Activeer 'place' tool
        setBuildTool('place');

        // Deselecteer als het al geselecteerd was
        if (selectedBuildObject && selectedBuildObject.name === item.name) {
            selectedBuildObject = null;
            div.classList.remove("selected");
        } else {
            // Deselecteer tools
            moveToolBtn.classList.remove('selected');
            deleteToolBtn.classList.remove('selected');
            // Deselecteer andere items
            document.querySelectorAll('.build-item.selected').forEach(el => el.classList.remove('selected'));
            // Selecteer dit item
            selectedBuildObject = item;
            div.classList.add("selected");
            isBuildObjectFlipped = false; // Reset flip state bij nieuwe selectie
        }
    };
    buildMenuContent.appendChild(div);
    });
}

function renderObjectSubCategories() {
    const subCategoryMenu = document.getElementById('objectSubCategoryMenu');
    subCategoryMenu.innerHTML = ''; // Leegmaken

    // Verzamel unieke subcategorieÃ«n
    const subCategories = [...new Set(buildableObjects
        .filter(item => item.category === 'objecten')
        .map(item => item.subCategory))];

    // Maak voor elke subcategorie een knop
    subCategories.forEach(subCat => {
        const btn = document.createElement('button');
        btn.className = 'category-btn'; // Gebruik dezelfde styling
        if (subCat === activeObjectSubCategory) {
            btn.classList.add('selected');
        }
        btn.dataset.subCategory = subCat;
        btn.title = subCat.charAt(0).toUpperCase() + subCat.slice(1); // bv. 'Blok'
        // Kies een icoon op basis van de subcategorie
        if (subCat === 'blok') {
            btn.textContent = 'ğŸ§±';
        } else if (subCat === 'muur') {
            btn.textContent = 'ğŸ–¼ï¸';
        }
        
        
        btn.onclick = () => {
            activeObjectSubCategory = subCat;
            renderObjectSubCategories(); // Her-render om selectie te tonen
            renderBuildItems(); // Her-render de items in de grid
        };
        subCategoryMenu.appendChild(btn);
    });
}

function setBuildTool(tool) {
    buildTool = tool;
    // Deselecteer meubel als we een andere tool kiezen
    if (tool === 'move' || tool === 'delete') {
        selectedBuildObject = null;
        document.querySelectorAll('.build-item.selected').forEach(el => el.classList.remove('selected'));
    }

    // Annuleer altijd een 'move' actie als we een andere tool selecteren
    if (movingObject) {
        objects.push(movingObject); // Zet het object terug
        movingObject = null;
    }
}

moveToolBtn.addEventListener('click', () => {
    const moveToolBtn = document.getElementById("moveToolBtn");
    const deleteToolBtn = document.getElementById("deleteToolBtn");

    if (buildTool === 'move') {
        setBuildTool('place'); // Terug naar neutraal
        moveToolBtn.classList.remove('selected');
    } else {
        setBuildTool('move');
        closeSecondaryWindows(); // Sluit andere vensters om conflicten te voorkomen
        moveToolBtn.classList.add('selected');
        deleteToolBtn.classList.remove('selected');
    }
});

deleteToolBtn.addEventListener('click', () => {
    const moveToolBtn = document.getElementById("moveToolBtn");
    const deleteToolBtn = document.getElementById("deleteToolBtn");

    setBuildTool(buildTool === 'delete' ? 'place' : 'delete');
    deleteToolBtn.classList.toggle('selected');
    moveToolBtn.classList.remove('selected');
});
// --- Kruisjes om menu's te sluiten ---
document.getElementById('closeBuildMenuBtn').addEventListener('click', () => {
    // Simuleer een klik op de hoofdknop om de sluit-logica te hergebruiken
    if (isBuildMode) {
        buildBtn.click();
    }
});

document.getElementById('closeChatLogBtn').addEventListener('click', () => {
    chatLog.style.display = 'none';
});

document.getElementById('closeInventoryBtn').addEventListener('click', () => {
    const inventory = document.getElementById('inventory');
    inventory.style.display = 'none';
});

buildCategoryMenu.addEventListener('click', (e) => {
    if (e.target.classList.contains('category-btn')) {
        // Verwijder 'selected' van alle categorieknoppen
        buildCategoryMenu.querySelectorAll('.category-btn').forEach(btn => {
            btn.classList.remove('selected');
        });
        // Deselecteer de losse tools
        setBuildTool('place');
        const moveToolBtn = document.getElementById("moveToolBtn");
        const deleteToolBtn = document.getElementById("deleteToolBtn");

        moveToolBtn.classList.remove('selected');
        deleteToolBtn.classList.remove('selected');

        // Annuleer een eventuele 'move' actie
        if (movingObject) {
            objects.push(movingObject); // Zet het object terug
            movingObject = null;
        }

        // Annuleer ook een 'place' actie (deselecteer object)
        if (selectedBuildObject) {
            selectedBuildObject = null;
            document.querySelectorAll('.build-item.selected').forEach(el => el.classList.remove('selected'));
            isBuildObjectFlipped = false;
        }

        // Voeg 'selected' toe aan de geklikte knop
        e.target.classList.add('selected');
        activeBuildCategory = e.target.dataset.category;
        // Wissel de zichtbare content
        document.getElementById('objectCategoryView').style.display = activeBuildCategory === 'objecten' ? 'flex' : 'none';
        document.getElementById('colorCategoryView').style.display = activeBuildCategory === 'kleur' ? 'flex' : 'none';        
        
        if (activeBuildCategory === 'objecten') {
            renderObjectSubCategories(); // Render de subcategorie-knoppen
            renderBuildItems(); // Render de items voor de actieve subcategorie
        }
    }
});



// --- Logica voor Kleur-tools ---
const colorToolsContainer = document.getElementById('colorTools');
colorToolsContainer.addEventListener('click', (e) => {
    const clickedButton = e.target.closest('.tool-btn');
    if (!clickedButton) return;

    // Update de geselecteerde tool
    colorTool = clickedButton.dataset.tool;

    // Update de visuele selectie
    colorToolsContainer.querySelectorAll('.tool-btn').forEach(btn => {
        btn.classList.remove('selected');
    });
    clickedButton.classList.add('selected');
});

// --- iro.js Color Picker Initialisatie ---
const colorPicker = new iro.ColorPicker("#color-picker-container", {
  width: 280, // Iets kleiner voor betere centrering
  color: selectedColor,
  borderWidth: 1,
  borderColor: "#fff",
  layout: [
    {
      component: iro.ui.Box, // Het vierkante kleurvlak
    },
    {
      component: iro.ui.Slider, // De slider voor de kleurtint
      options: { sliderType: 'hue' }
    }
  ]
});

// Update de 'selectedColor' variabele wanneer de kleur verandert
function updateColor(color, source) {
    selectedColor = color.hexString;
    document.getElementById('colorPreview').style.backgroundColor = selectedColor;

    // Voorkom een oneindige loop door niet te updaten als de input de bron was
    if (source !== 'input') {
        document.getElementById('hexInput').value = selectedColor;
    }
}

colorPicker.on('color:change', color => updateColor(color, 'picker'));

document.getElementById('hexInput').addEventListener('change', (e) => {
    const hex = e.target.value;
    // Simpele validatie voor een hex kleur
    if (/^#([0-9A-F]{3}){1,2}$/i.test(hex)) {
        colorPicker.color.hexString = hex;
        // De 'color:change' event van de picker wordt automatisch getriggerd,
        // dus we hoeven updateColor() hier niet expliciet aan te roepen.
    }
});

buildBtn.addEventListener("click", () => {
    isBuildMode = !isBuildMode;
    if (isBuildMode) {
        // Zorg dat de juiste view zichtbaar is bij openen
        document.querySelector('.category-btn.selected').click();
        buildMenu.style.display = "flex";
        renderObjectSubCategories(); // Render subcats bij openen
        renderBuildItems(); // Render items bij openen
    } else {
        buildMenu.style.display = "none";
        // Deselecteer alles bij sluiten
        selectedBuildObject = null;
        document.querySelectorAll('.build-item.selected').forEach(el => el.classList.remove('selected'));
        isBuildObjectFlipped = false;
        setBuildTool('place');
        const moveToolBtn = document.getElementById("moveToolBtn");
        const deleteToolBtn = document.getElementById("deleteToolBtn");

        moveToolBtn.classList.remove('selected');
        deleteToolBtn.classList.remove('selected');
        // Reset naar objecten categorie voor de volgende keer
        document.querySelector('.category-btn[data-category="objecten"]').click();
    }
});







// Chat
const chatInput = document.getElementById("chatInput");
let chatMessages = [];
let allRoomMessages = [];

const chatLog = document.getElementById("chatLog");
const openChatLogBtn = document.getElementById("openChatLog");

openChatLogBtn.addEventListener("click", () => {
    if (chatLog.style.display === "block") {
        chatLog.style.display = "none";
    } else {
        chatLog.style.display = "block";
        chatLog.scrollTop = chatLog.scrollHeight; // naar beneden scrollen
    }
});


function sendChatMessage(text, user = "Jij") {
    const now = Date.now();

    const msg = {
        text,
        user,
        time: now,
        duration: 5000,
        currentY: undefined
    };

    chatMessages.push(msg);
    allRoomMessages.push(msg);

    updateChatLog();
}

function updateChatLog() {
    const content = document.getElementById("chatLogContent");
    content.innerHTML = "";

    allRoomMessages.forEach(m => {
        const time = new Date(m.time).toLocaleTimeString("nl-NL", {
            hour: "2-digit",
            minute: "2-digit"
        });

        const line = document.createElement("div");
        line.style.marginBottom = "6px";
        line.style.wordBreak = "break-word";
        line.innerHTML = `<span style="color:#888">[${time}]</span> <b>${m.user}:</b> ${m.text}`;

        content.appendChild(line);
    });

    content.scrollTop = content.scrollHeight;

}

// Hulp functie: heuristiek (Manhattan afstand)
function heuristic(a, b) {
    return Math.abs(a.x - b.x) + Math.abs(a.y - b.y);
}

function findPath(start, end) {
    const openSet = [];
    const closedSet = new Set();
    const cameFrom = new Map();


    function nodeKey(n){ return `${n.x},${n.y}`; }

    const gScore = {};
    const fScore = {};

    gScore[nodeKey(start)] = 0;
    fScore[nodeKey(start)] = Math.abs(start.x - end.x) + Math.abs(start.y - end.y);

    openSet.push({ ...start, f: fScore[nodeKey(start)] });
    
    while(openSet.length > 0){
        // Kies node met laagste f
        openSet.sort((a,b)=>a.f-b.f);
        const current = openSet.shift();

        if(current.x === end.x && current.y === end.y){
            // Reconstruct path
            const path = [];
            let currKey = nodeKey(current);
            while(cameFrom.has(currKey)){
                path.push(cameFrom.get(currKey));
                currKey = nodeKey(cameFrom.get(currKey));
            }
            path.reverse();

            // Voeg het eindpunt zelf toe zodat de speler er echt naartoe gaat
            path.push({x: end.x, y: end.y});

            return path;
        }

        closedSet.add(nodeKey(current));

        // buren inclusief diagonalen
        const neighbors = [
            {x: current.x+1, y: current.y},
            {x: current.x-1, y: current.y},
            {x: current.x, y: current.y+1},
            {x: current.x, y: current.y-1},
            {x: current.x+1, y: current.y+1}, 
            {x: current.x+1, y: current.y-1},
            {x: current.x-1, y: current.y+1},
            {x: current.x-1, y: current.y-1}
        ].filter(n => n.x >=0 && n.x < mapW && n.y >=0 && n.y < mapH);

        for(let neighbor of neighbors){
            const nKey = nodeKey(neighbor);
            if(closedSet.has(nKey)) continue;
            if(isBlocked(neighbor.x, neighbor.y)) continue;

            const tentativeG = gScore[nodeKey(current)] + 1;

            if(!gScore.hasOwnProperty(nKey) || tentativeG < gScore[nKey]){
                cameFrom.set(nKey, {x: current.x, y: current.y});
                gScore[nKey] = tentativeG;
                fScore[nKey] = tentativeG + Math.abs(neighbor.x - end.x) + Math.abs(neighbor.y - end.y);
                if(!openSet.some(n => n.x===neighbor.x && n.y===neighbor.y)){
                    openSet.push({ ...neighbor, f: fScore[nKey] });
                }
            }
        }
    }

    // geen pad gevonden
    return [];
}



// Tile naar scherm
function toScreen(ix, iy) {
    const sx = (ix - iy) * tileW/2;
    const sy = (ix + iy) * tileH/2;
    return {sx, sy};
}

function toTile(mx, my){
    const cx = (mx - canvas.width/2 - camX)/scale;
    const cy = (my - canvas.height/4 - camY)/scale;

    const tyOffset = 1.5; // capsule is 1.5 tegel hoog
    const tx = (cx/tileW + cy/tileH);
    const ty = (cy/tileH - cx/tileW) - tyOffset + 1; // +1 zodat onderkant op tegel
    return {x: Math.floor(tx), y: Math.floor(ty)};
}

function toWorld(mx, my) {
    // Converteert schermcoÃ¶rdinaten (muis) naar wereldcoÃ¶rdinaten (isometrisch)
    const worldMouseX = (mx - canvas.width / 2 - camX) / scale;
    const worldMouseY = (my - canvas.height / 4 - camY) / scale;

    // Inverse transformatie van toScreen
    const isoX = worldMouseX / (tileW / 2);
    const isoY = worldMouseY / (tileH / 2);

    const worldX = (isoX + isoY) / 2;
    const worldY = (isoY - isoX) / 2;
    return { x: worldX, y: worldY };
}


function wrapText(text, maxWidth) {    
    const words = text.split(" ");
    const lines = [];
    let line = "";

    for (let word of words) {
        // Check of het woord zelf al te breed is
        if (ctx.measureText(word).width > maxWidth) {
            // Eerst de huidige regel opslaan
            if (line !== "") {
                lines.push(line);
                line = "";
            }

            // Breek het woord op
            let part = "";
            for (let char of word) {
                const test = part + char;
                if (ctx.measureText(test + "-").width > maxWidth) {
                    lines.push((part + "-").trim());
                    part = char;
                } else {
                    part = test;
                }
            }
            line = part; // Het resterende deel wordt de nieuwe regel
        } else {
            const testLine = line + word + " ";
            if (ctx.measureText(testLine).width > maxWidth) {
                // Voeg de vorige regel toe, maar alleen als deze niet leeg is
                if (line.trim() !== "") lines.push(line.trim());
                line = word + " ";
            } else {
                line = testLine;
            }
        }
    }

    // Voeg de allerlaatste regel toe, maar alleen als deze niet leeg is
    if (line.trim() !== "") lines.push(line.trim());
    return lines;
}



function drawTiles() {
    for (let y = 0; y < mapH; y++) {
        for (let x = 0; x < mapW; x++) {
            const { sx, sy } = toScreen(x, y);
            const tileKey = `${x},${y}`;
 
            // Basis tegel
            let fill = "#444";

            // Check of er een custom kleur is voor deze tegel (dit overschrijft de basiskleur)
            if (tileColors[tileKey]) {
                fill = tileColors[tileKey];
            }

            ctx.beginPath();
            ctx.moveTo(sx, sy);
            ctx.lineTo(sx + tileW / 2, sy + tileH / 2);
            ctx.lineTo(sx, sy + tileH);
            ctx.lineTo(sx - tileW / 2, sy + tileH / 2);
            ctx.closePath();
            ctx.fillStyle = fill;
            ctx.fill();

            // Tile nummer tekenen
            ctx.fillStyle = "white";
            ctx.font = "10px Arial";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            const tileNum = y * mapW + x; // nummer van 0 t/m mapW*mapH-1
            ctx.fillText(tileNum, sx, sy + tileH / 2);
        }
    }

    // Teken het gehighlighte pad
    if (highlightedPath.length > 0) {
        ctx.fillStyle = "rgba(255, 255, 255, 0.5)"; // Wit met meer zichtbaarheid
        highlightedPath.forEach(tile => {
            const { sx, sy } = toScreen(tile.x, tile.y);
            ctx.beginPath();
            ctx.moveTo(sx, sy);
            ctx.lineTo(sx + tileW / 2, sy + tileH / 2);
            ctx.lineTo(sx, sy + tileH);
            ctx.lineTo(sx - tileW / 2, sy + tileH / 2);
            ctx.closePath();
            ctx.fill();
        });
    }


    // Hover-effect voor de kwast
    if (isBuildMode && activeBuildCategory === 'kleur' && hoverTarget) {
        if (hoverTarget.type === 'tile') {
            const { sx, sy } = toScreen(hoverTarget.id.x, hoverTarget.id.y);
            ctx.beginPath();
            ctx.moveTo(sx, sy);
            ctx.lineTo(sx + tileW / 2, sy + tileH / 2);
            ctx.lineTo(sx, sy + tileH);
            ctx.lineTo(sx - tileW / 2, sy + tileH / 2);
            ctx.closePath();
            ctx.fillStyle = "rgba(255,255,255,0.5)";
            ctx.fill();
        } else if (hoverTarget.type === 'wall') {
            // Dit wordt afgehandeld in de drawWall functies
        }
    } else if (hoverCell) { // Oude hover voor padvinden
        const { sx, sy } = toScreen(hoverCell.x, hoverCell.y);
        ctx.beginPath();
        ctx.moveTo(sx, sy);
        ctx.lineTo(sx + tileW / 2, sy + tileH / 2);
        ctx.lineTo(sx, sy + tileH);
        ctx.lineTo(sx - tileW / 2, sy + tileH / 2);
        ctx.closePath();
        ctx.fillStyle = "rgba(255,255,255,0.5)";
        ctx.fill();
    }

    // Bouwmodus hover (plaatsen & verplaatsen)
    if ((selectedBuildObject?.placement === 'floor' || movingObject || draggedObject) && hoverCell) {
      const playerOnTile = Math.floor(ball.x) === hoverCell.x && Math.floor(ball.y) === hoverCell.y;
      const isOccupied = isBlocked(hoverCell.x, hoverCell.y);
      const isItemTileOccupied = isItemOccupied(hoverCell.x, hoverCell.y); // NIEUW: Check voor items
      const isValidPlacement = !isOccupied && !playerOnTile && !isItemTileOccupied;

      const { sx, sy } = toScreen(hoverCell.x, hoverCell.y);

      // Teken de gekleurde tegel overlay (groen/rood)
      ctx.beginPath();
      ctx.moveTo(sx, sy);
      ctx.lineTo(sx + tileW / 2, sy + tileH / 2);
      ctx.lineTo(sx, sy + tileH);
      ctx.lineTo(sx - tileW / 2, sy + tileH / 2);
      ctx.closePath();
      ctx.fillStyle = isValidPlacement ? "rgba(0, 255, 0, 0.5)" : "rgba(255, 0, 0, 0.5)";
      ctx.fill();

      // De preview van het object zelf wordt nu in de renderList getekend voor correcte diepte.
    } else if (selectedBuildObject?.placement === 'wall' && hoverTarget?.type === 'wall') {
        // Preview voor muurobjecten
        const wallId = hoverTarget.id;
        const isOccupied = wallObjects.some(wo => wo.wallId === wallId);
        const isValidPlacement = !isOccupied;

        // Teken de preview direct in de juiste wall-draw functie
        // We voegen een tijdelijke vlag toe aan hoverTarget
        hoverTarget.preview = {
            color: isValidPlacement ? "rgba(0, 255, 0, 0.5)" : "rgba(255, 0, 0, 0.5)",
            image: wallItemImg,
            valid: isValidPlacement
        };
    } else if (hoverTarget?.preview) {
        // Reset de preview als we niet meer hoveren
        delete hoverTarget.preview;
    }

    // Verwijder-modus hover
    if (buildTool === 'delete' && hoverCell) {
        const objectOnTile = objects.find(o => o.x === hoverCell.x && o.y === hoverCell.y);
        const itemOnTile = items.find(item => Math.floor(item.x) === hoverCell.x && Math.floor(item.y) === hoverCell.y);
        if (objectOnTile || itemOnTile) {
            const { sx, sy } = toScreen(hoverCell.x, hoverCell.y);

            // Teken een rode overlay op de tegel
            ctx.beginPath();
            ctx.moveTo(sx, sy);
            ctx.lineTo(sx + tileW / 2, sy + tileH / 2);
            ctx.lineTo(sx, sy + tileH);
            ctx.lineTo(sx - tileW / 2, sy + tileH / 2);
            ctx.closePath();
            ctx.fillStyle = "rgba(255, 0, 0, 0.7)";
            ctx.fill();
        }
    }
}





function drawBall() {
    const {sx, sy} = toScreen(ball.x, ball.y); // x,y = midden van tegel horizontaal, y = midden van tegel

    const capsuleWidth = 32;
    const capsuleHeight = 48;
    const radius = capsuleWidth / 2;

    // Onderkant capsule = tegel midden
    const drawY = sy - hopOffset - capsuleHeight;

    // Capsule speler
    ctx.fillStyle = "red";
    ctx.beginPath();
    ctx.moveTo(sx - capsuleWidth/2, drawY + radius);
    ctx.arcTo(sx - capsuleWidth/2, drawY + capsuleHeight, sx + capsuleWidth/2, drawY + capsuleHeight, radius);
    ctx.arcTo(sx + capsuleWidth/2, drawY + capsuleHeight, sx + capsuleWidth/2, drawY, radius);
    ctx.arcTo(sx + capsuleWidth/2, drawY, sx - capsuleWidth/2, drawY, radius);
    ctx.arcTo(sx - capsuleWidth/2, drawY, sx - capsuleWidth/2, drawY + capsuleHeight, radius);
    ctx.closePath();
    ctx.fill();

    // Hoed boven capsule
    const hatWidth = 32;
    const hatHeight = 16;
    const capsuleTop = drawY;
    ctx.fillStyle = "blue";
    ctx.beginPath();
    ctx.moveTo(sx, capsuleTop - hatHeight);
    ctx.lineTo(sx - hatWidth/2, capsuleTop);
    ctx.lineTo(sx + hatWidth/2, capsuleTop);
    ctx.closePath();
      ctx.fill();

}

// Achterwand
function drawTopWall() {
    const wallHeight = 150;
    // Loop van achter naar voren voor correcte diepte
    for (let x = mapW - 1; x >= 0; x--) {
        const wallId = `top_${x}`;
        const topLeft = toScreen(x, 0);
        const topRight = toScreen(x + 1, 0);

        // Teken altijd eerst de basiskleur van de muur
        ctx.fillStyle = wallColors[wallId] || "#555";
        ctx.beginPath();
        ctx.moveTo(topLeft.sx, topLeft.sy - wallHeight);
        ctx.lineTo(topRight.sx, topRight.sy - wallHeight);
        ctx.lineTo(topRight.sx, topRight.sy);
        ctx.lineTo(topLeft.sx, topLeft.sy);
        ctx.closePath();
        ctx.fill();

        // Teken de highlight eroverheen als de muis erboven is
        if (hoverTarget && hoverTarget.type === 'wall' && hoverTarget.id === wallId) {
            ctx.fillStyle = "rgba(255,255,255,0.5)";
            ctx.fill(); // Gebruik hetzelfde pad, dus vul opnieuw
        }

        // Teken een eventueel muurobject
        const wallObject = wallObjects.find(wo => wo.wallId === wallId);
        if (wallObject) {
            // Centreer het object op het muursegment
            const objX = (topLeft.sx + topRight.sx) / 2;
            const objY = topLeft.sy; // Bovenkant van de vloer (onderkant van de muur)

            if (wallObject.flipped) {
                ctx.save();
                ctx.scale(-1, 1);
                ctx.drawImage(wallItemImg, -objX - wallItemImg.width / 2, objY - wallItemImg.height + 16); // 16px omlaag
                ctx.restore();
            } else {
                ctx.drawImage(wallItemImg, objX - wallItemImg.width / 2, objY - wallItemImg.height + 16); // 16px omlaag
            }
        }

        // Teken de preview voor een nieuw muurobject
        if (hoverTarget?.preview && hoverTarget.id === wallId) {
            ctx.fillStyle = hoverTarget.preview.color;
            ctx.fill();
            // Teken nu ook de afbeelding van de preview
            const objX = (topLeft.sx + topRight.sx) / 2;
            const objY = topLeft.sy; // Bovenkant van de vloer (onderkant van de muur)
            ctx.globalAlpha = 0.7; // Maak de preview transparant

            if (isBuildObjectFlipped) {
                ctx.save();
                ctx.scale(-1, 1);
                ctx.drawImage(hoverTarget.preview.image, -objX - hoverTarget.preview.image.width / 2, objY - hoverTarget.preview.image.height + 16); // 16px omlaag
                ctx.restore();
            } else {
                ctx.drawImage(hoverTarget.preview.image, objX - hoverTarget.preview.image.width / 2, objY - hoverTarget.preview.image.height + 16); // 16px omlaag
            }
            ctx.globalAlpha = 1; // Reset alpha
        }
    }
}

// Linkermuur
function drawLeftWall() {
    const wallHeight = 150;
    // Loop van achter naar voren
    for (let y = mapH - 1; y >= 0; y--) {
        const wallId = `left_${y}`;
        const leftTop = toScreen(0, y);
        const leftBottom = toScreen(0, y + 1);

        // Teken altijd eerst de basiskleur van de muur
        ctx.fillStyle = wallColors[wallId] || "#666";
        ctx.beginPath();
        ctx.moveTo(leftTop.sx, leftTop.sy - wallHeight);
        ctx.lineTo(leftBottom.sx, leftBottom.sy - wallHeight);
        ctx.lineTo(leftBottom.sx, leftBottom.sy);
        ctx.lineTo(leftTop.sx, leftTop.sy);
        ctx.closePath();
        ctx.fill();

        // Teken de highlight eroverheen als de muis erboven is
        if (hoverTarget && hoverTarget.type === 'wall' && hoverTarget.id === wallId) {
            ctx.fillStyle = "rgba(255,255,255,0.5)";
            ctx.fill(); // Gebruik hetzelfde pad, dus vul opnieuw
        }

        // Teken een eventueel muurobject
        const wallObject = wallObjects.find(wo => wo.wallId === wallId);
        if (wallObject) {
            const objX = (leftTop.sx + leftBottom.sx) / 2; // Horizontaal midden van de muur
            const objY = leftTop.sy; // Bovenkant van de vloer (onderkant van de muur)

            if (wallObject.flipped) {
                ctx.save();
                ctx.scale(-1, 1);
                ctx.drawImage(wallItemImg, -objX - wallItemImg.width / 2, objY - wallItemImg.height + 16); // 16px omlaag
                ctx.restore();
            } else {
                ctx.drawImage(wallItemImg, objX - wallItemImg.width / 2, objY - wallItemImg.height + 16); // 16px omlaag
            }
        }

        // Teken de preview voor een nieuw muurobject
        if (hoverTarget?.preview && hoverTarget.id === wallId) {
            ctx.fillStyle = hoverTarget.preview.color;
            ctx.fill();
            // Teken nu ook de afbeelding van de preview
            const objX = (leftTop.sx + leftBottom.sx) / 2;
            const objY = leftTop.sy; // Bovenkant van de vloer (onderkant van de muur)
            ctx.globalAlpha = 0.7; // Maak de preview transparant
            if (isBuildObjectFlipped) {
                ctx.save();
                ctx.scale(-1, 1);
                ctx.drawImage(hoverTarget.preview.image, -objX - hoverTarget.preview.image.width / 2, objY - hoverTarget.preview.image.height + 16); // 16px omlaag
                ctx.restore();
            } else {
                ctx.drawImage(hoverTarget.preview.image, objX - hoverTarget.preview.image.width / 2, objY - hoverTarget.preview.image.height + 16); // 16px omlaag
            }
            ctx.globalAlpha = 1; // Reset alpha
        }
    }
}

let lastTypingTime = 0;
const typingFadeStart = 3000;  // 3 seconden wachten na laatste type
const typingFadeDuration = 1000; // fade tijd 1 seconde

function getActiveBalloonCount() {
    const now = Date.now();
    return chatMessages.filter(
        m => now - m.time < m.duration
    ).length;
}


chatInput.addEventListener("input", () => {
    const activeCount = getActiveBalloonCount();

    // âŒ blokkeren bij 5 ballonnen
    if (activeCount >= 5) {
    chatInput.value = "";
    chatInput.disabled = true;
    chatInput.placeholder = "Even wachten...";
    charCounter.textContent = `0 / ${MAX_CHARS}`;
    return;
}


    // âœ… weer mogen typen
    chatInput.disabled = false;
    chatInput.placeholder = "Typ hier je bericht...";
    chatInput.style.color = "#000";

    lastTypingTime = Date.now();

    if (chatInput.value.length > MAX_CHARS) {
        chatInput.value = chatInput.value.slice(0, MAX_CHARS);
    }

    // Update char counter
    charCounter.textContent = `${chatInput.value.length} / ${MAX_CHARS}`;
    charCounter.style.color = chatInput.value.length >= MAX_CHARS ? "#ff4d4d" : "#aaa";
});




window.addEventListener("keydown", (e) => {
    const active = document.activeElement;

    // Als we in bouwmodus zijn, handel alleen de rotatie af.
    if (isBuildMode && activeBuildCategory === 'objecten' && (selectedBuildObject || movingObject)) {
        if (e.key.toLowerCase() === 'r') {
            isBuildObjectFlipped = !isBuildObjectFlipped;
            // Als we een object verplaatsen, update ook de 'flipped' state van dat object direct.
            if (movingObject) {
                movingObject.flipped = isBuildObjectFlipped;
            }
        }
        return; // Stop verdere keyboard-logica in bouwmodus
    }

    // âŒ Geen bouwmodus: focus de chat, maar sluit speciale toetsen uit
    if (
        active !== chatInput &&
        !["Shift", "Control", "Alt", "Meta", "Enter"].includes(e.key)
    ) {
        chatInput.focus();
    }

    // Enter = bericht versturen
    if (active === chatInput && e.key === "Enter") {
        if (chatInput.value.trim() !== "") {
            sendChatMessage(chatInput.value.trim());
            chatInput.value = "";
            charCounter.textContent = `0 / ${MAX_CHARS}`;
            charCounter.style.color = "#aaa";
        }
        e.preventDefault();
    }
});


function drawChatBallon() {
    const now = Date.now();

    const paddingX = 16;
    const paddingY = 12;
    const maxWidth = 200;
    const minWidth = 60;
    const lineHeight = 18;
    const gap = 18;
    const fadeTime = 1000;
    const offsetAbovePlayer = 96;

    const world = toScreen(ball.x, ball.y);
    const screenX = world.sx * scale + canvas.width / 2 + camX;
    const screenY = world.sy * scale + canvas.height / 4 + camY - hopOffset * scale;

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // 1ï¸âƒ£ actieve chatberichten
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const activeMessages = chatMessages.filter(
        m => now - m.time < m.duration
    );

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // 2ï¸âƒ£ typing indicator als "virtueel bericht"
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const timeSinceLastType = now - lastTypingTime;
    const typingActive =
    lastTypingTime > 0 &&
    chatInput.value.length > 0 &&
    timeSinceLastType < typingFadeStart + typingFadeDuration;


    const virtualMessages = [];

    if (typingActive) {
        virtualMessages.push({
            text: "...",
            isTyping: true,
            time: lastTypingTime
        });
    }

    // berichten + typing samenvoegen
    const stack = [...activeMessages, ...virtualMessages];

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // 3ï¸âƒ£ offsets berekenen (alles duwt elkaar omhoog)
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    let offsets = [];
    let totalOffset = 0;

    for (let i = stack.length - 1; i >= 0; i--) {
        const lines = wrapText(
            stack[i].text,
            maxWidth - paddingX * 2
        );
        const height = lines.length * lineHeight + paddingY * 2;
        offsets[i] = totalOffset;
        totalOffset += height + gap;
    }

    ctx.save();
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.font = "14px Arial";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";

    function drawSingleBalloon(lines, offset, alpha = 1) {
        const textWidth = Math.max(
            ...lines.map(l => ctx.measureText(l).width)
        );

        const width = Math.max(
            minWidth,
            Math.min(maxWidth, textWidth + paddingX * 2)
        );

        const height = lines.length * lineHeight + paddingY * 2;
        const targetY =
            screenY - offsetAbovePlayer - offset - height;

        const r = lines.length === 1 ? height / 2 : 14;

        ctx.globalAlpha = alpha;

        ctx.beginPath();
        ctx.moveTo(screenX - width / 2 + r, targetY);
        ctx.lineTo(screenX + width / 2 - r, targetY);
        ctx.quadraticCurveTo(
            screenX + width / 2,
            targetY,
            screenX + width / 2,
            targetY + r
        );
        ctx.lineTo(
            screenX + width / 2,
            targetY + height - r
        );
        ctx.quadraticCurveTo(
            screenX + width / 2,
            targetY + height,
            screenX + width / 2 - r,
            targetY + height
        );
        ctx.lineTo(
            screenX - width / 2 + r,
            targetY + height
        );
        ctx.quadraticCurveTo(
            screenX - width / 2,
            targetY + height,
            screenX - width / 2,
            targetY + height - r
        );
        ctx.lineTo(screenX - width / 2, targetY + r);
        ctx.quadraticCurveTo(
            screenX - width / 2,
            targetY,
            screenX - width / 2 + r,
            targetY
        );
        ctx.closePath();

        ctx.fillStyle = "white";
        ctx.fill();
  

        lines.forEach((line, i) => {
            ctx.fillStyle = "black";
            ctx.fillText(
                line,
                screenX,
                targetY +
                    paddingY +
                    lineHeight / 2 +
                    i * lineHeight
            );
        });

        ctx.globalAlpha = 1;
    }

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // 4ï¸âƒ£ alles tekenen
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    stack.forEach((m, i) => {
        let alpha = 1;

        if (!m.isTyping) {
            const age = now - m.time;
            if (age > m.duration - fadeTime) {
                alpha =
                    1 -
                    (age - (m.duration - fadeTime)) /
                        fadeTime;
            }
        } else {
            if (timeSinceLastType > typingFadeStart) {
                alpha =
                    1 -
                    (timeSinceLastType -
                        typingFadeStart) /
                        typingFadeDuration;
            }
        }

        const lines = wrapText(
            m.text,
            maxWidth - paddingX * 2
        );

        drawSingleBalloon(lines, offsets[i], alpha);
    });

    ctx.restore();
}


let mousePos = { x: 0, y: 0 };
// Event listeners
canvas.addEventListener("mousemove", e=>{
    mousePos = { x: e.clientX, y: e.clientY };

    const {x, y} = toTile(e.clientX, e.clientY);
    hoverCell = (x>=0 && x<mapW && y>=0 && y<mapH) ? {x,y} : null;

    // Update draggedItem position if dragging
    if (isItemDragging && draggedItem) {
        const worldPos = toWorld(e.clientX, e.clientY);
        draggedItem.x = worldPos.x;
        draggedItem.y = worldPos.y;
    }

    // --- Hover detectie voor muren en tegels in bouwmodus ---
    if (isBuildMode) {
        hoverTarget = null;
        const wallHeight = 150;
        const mouseWorldX = (e.clientX - (canvas.width / 2 + camX)) / scale;
        const mouseWorldY = (e.clientY - (canvas.height / 4 + camY)) / scale;

        // Check top walls (van voor naar achter voor correcte selectie)
        for (let x = 0; x < mapW; x++) {
            const p1 = toScreen(x, 0);
            const p2 = toScreen(x + 1, 0);
            // Bounding box van het muursegment
            // We gebruiken een iets complexere check voor de isometrische vorm
            const inside = isInside(mouseWorldX, mouseWorldY, [p1, p2, {sx: p2.sx, sy: p2.sy - wallHeight}, {sx: p1.sx, sy: p1.sy - wallHeight}]);
            if (inside) {
                hoverTarget = { type: 'wall', id: `top_${x}` };
                break;
            }
        }

        // Als geen top-muur, check linker muren
        if (!hoverTarget) {
            for (let y = 0; y < mapH; y++) {
                const p1 = toScreen(0, y);
                const p2 = toScreen(0, y + 1);
                // Bounding box van het muursegment
                const inside = isInside(mouseWorldX, mouseWorldY, [p1, p2, {sx: p2.sx, sy: p2.sy - wallHeight}, {sx: p1.sx, sy: p1.sy - wallHeight}]);
                if (inside) {
                    hoverTarget = { type: 'wall', id: `left_${y}` };
                    break;
                }
            }
        }

        // Als nog steeds geen muur, check voor een tegel
        if (!hoverTarget && hoverCell) {
            hoverTarget = { type: 'tile', id: hoverCell };
        }
    }

    if(isCameraDragging){ // Gebruik de nieuwe variabele
        // Als we een object slepen, beweegt de camera niet handmatig mee.
        // De camera volgt de muis via de `loop` functie.
        // Deze check is niet meer nodig hier, omdat isCameraDragging en draggedObject elkaar uitsluiten.
        // if (draggedObject) return; 

        const dx = e.clientX - dragStart.x;
        const dy = e.clientY - dragStart.y;
        
        camX = camStart.x + dx;
        camY = camStart.y + dy;
    } 
});

// Helper functie om te checken of een punt in een polygoon (de muur) ligt
function isInside(x, y, vs) {
    // ray-casting algorithm
    let inside = false;
    for (let i = 0, j = vs.length - 1; i < vs.length; j = i++) {
        const xi = vs[i].sx, yi = vs[i].sy;
        const xj = vs[j].sx, yj = vs[j].sy;

        const intersect = ((yi > y) !== (yj > y))
            && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
        if (intersect) inside = !inside;
    }
    return inside;
}


canvas.addEventListener("mousedown", e => {
    if (e.button === 0) { // Linkermuisknop
        // --- Logica voor verslepen van 'moveable' objecten (buiten bouwmodus) ---
        if (!isBuildMode) {
            const {x, y} = toTile(e.clientX, e.clientY);
            const objectToDragIndex = objects.findIndex(o => o.x === x && o.y === y && o.moveable);
 
            if (objectToDragIndex > -1) {
                // Sla de staat van de vensters op VOORDAT ze gesloten worden
                windowStatesBeforeDrag = {
                    chat: document.getElementById('chatLog').style.display,
                    inventory: document.getElementById('inventory').style.display,
                    build: document.getElementById('buildMenu').style.display
                };
                closeAllWindows(); // Sluit alle vensters bij het oppakken van een object
                draggedObject = objects.splice(objectToDragIndex, 1)[0];
                draggedObjectOriginalPos = { x: draggedObject.x, y: draggedObject.y };
                camOriginalPos = { x: camX, y: camY }; // Sla de huidige camera positie op
                isObjectDragging = true; // Start de sleep-modus voor het object
                camSmooth = false; // Stop eventuele smooth-beweging
                return;
            }

            // --- Logica voor het oppakken van items ---
            const itemToPickIndex = items.findIndex(item => {
                const itemTileX = Math.floor(item.x);
                const itemTileY = Math.floor(item.y);
                return itemTileX === x && itemTileY === y;
            });

            if (itemToPickIndex > -1) {
                // Sla de staat van de vensters op
                windowStatesBeforeDrag = {
                    chat: document.getElementById('chatLog').style.display,
                    inventory: document.getElementById('inventory').style.display,
                    build: document.getElementById('buildMenu').style.display
                };
                closeAllWindows(); // Sluit andere vensters

                // Start de sleep-modus voor het item
                draggedItem = items.splice(itemToPickIndex, 1)[0];
                draggedItemOriginalPos = { x: draggedItem.x, y: draggedItem.y };
                isItemDragging = true;
                camSmooth = false;

                // Open de inventaris zodat de gebruiker de optie heeft om het item daarheen te slepen
                inventory.style.display = 'flex';
                renderInventoryItems();
                console.log("Item vastgepakt!", draggedItem);
                return; // Stop verdere acties na het oppakken
            }
        }
        // Sla de startpositie op voor een mogelijke klik-actie (geen drag)
        dragStart.x = e.clientX;
        dragStart.y = e.clientY;
    }
    // Sla de startpositie op voor een mogelijke klik-actie (geen drag) - Ook voor rechtermuisknop
    dragStart.x = e.clientX;
    dragStart.y = e.clientY;
    if (e.button === 2) { // Rechtermuisknop
        camStart.x = camX;
        camStart.y = camY;
        isCameraDragging = true; // Start camera slepen
        camSmooth = false;
    }
});

canvas.addEventListener("mouseup", e => {    
    // Als we hier komen, was het geen object-sleep, dus het kan een klik zijn
    // of een drag die geen object betrof.

    const dx = e.clientX - dragStart.x;
    const dy = e.clientY - dragStart.y;

    // --- Afhandeling van het loslaten van een versleept item ---
    if (isItemDragging && e.button === 0) {
        const {x, y} = toTile(e.clientX, e.clientY);
        const inventoryRect = inventory.getBoundingClientRect();
        const isOverInventory = e.clientX >= inventoryRect.left && e.clientX <= inventoryRect.right && e.clientY >= inventoryRect.top && e.clientY <= inventoryRect.bottom;

        if (isOverInventory && inventory.style.display === 'flex') { // Alleen toevoegen aan inventaris als deze open is
            inventoryItems.push(draggedItem);
            renderInventoryItems();
            console.log("Item in inventaris geplaatst:", draggedItem);
        } else {
            const playerOnTile = Math.floor(ball.x) === x && Math.floor(ball.y) === y;
            const isOccupiedByObject = isBlocked(x, y);
            const isOccupiedByItem = isItemOccupied(x, y);
            const isValidPlacement = x >= 0 && x < mapW && y >= 0 && y < mapH && !isOccupiedByObject && !playerOnTile && !isOccupiedByItem;

            if (isValidPlacement) {
                draggedItem.x = x + 0.5;
                draggedItem.y = y + 0.5;
                items.push(draggedItem);
                console.log("Item teruggeplaatst op kaart:", draggedItem);
        } else {
            // Plaats terug op de originele positie als de nieuwe plek ongeldig is
            draggedItem.x = draggedItemOriginalPos.x;
            draggedItem.y = draggedItemOriginalPos.y;
            items.push(draggedItem);
            console.log("Ongeldige plaatsing, item terug naar originele plek:", draggedItem);
        }
        }

        // Reset alle sleep-gerelateerde variabelen voor items
        isItemDragging = false;
        draggedItem = null;
        draggedItemOriginalPos = null;

        // Heropen de vensters die open stonden
        if (windowStatesBeforeDrag) {
            if (windowStatesBeforeDrag.chat) document.getElementById('chatLog').style.display = windowStatesBeforeDrag.chat;
            // We laten de inventory open als die al open was, of als we er iets in hebben gesleept.
            if (windowStatesBeforeDrag.inventory === 'flex' || isOverInventory) {
                 inventory.style.display = 'flex';
            } else {
                 inventory.style.display = 'none';
            }
            if (windowStatesBeforeDrag.build === 'flex') {
                buildBtn.click();
            }
            windowStatesBeforeDrag = null;
        }
        return; // Belangrijk: stop verdere uitvoering
    }

    // Als we in bouwmodus zijn en het een klik was, handel de tool-actie af
    if (e.button === 0 && isBuildMode && Math.sqrt(dx*dx + dy*dy) < 5) { // Alleen uitvoeren bij linkermuisknop
        const {x, y} = toTile(e.clientX, e.clientY);

        // Plaatsen kan op een tegel (x/y >= 0) of op een muur (hoverTarget.type === 'wall')
        if (activeBuildCategory === 'objecten' && ((x >= 0 && y >= 0) || hoverTarget?.type === 'wall')) {
            const playerOnTile = Math.floor(ball.x) === x && Math.floor(ball.y) === y;
            const isOccupied = isBlocked(x, y);
            const isItemTileOccupied = isItemOccupied(x, y);

            // --- Object Tool Logica ---
            switch (buildTool) {
                case 'place':
                    if (selectedBuildObject?.placement === 'floor' && !isOccupied && !playerOnTile && !isItemTileOccupied && selectedBuildObject.name) {
                        objects.push({ ...selectedBuildObject, x: x, y: y, flipped: isBuildObjectFlipped });
                    } else if (selectedBuildObject?.placement === 'wall' && hoverTarget?.type === 'wall') {
                        const wallId = hoverTarget.id; // De ID van de muur waar we op klikken
                        const isWallOccupied = wallObjects.some(wo => wo.wallId === wallId);
                        if (!isWallOccupied) {
                            wallObjects.push({ wallId: wallId, name: selectedBuildObject.name, flipped: isBuildObjectFlipped });
                        }
                    }
                    break;
                case 'move':
                    if (movingObject) {
                        if (!isOccupied && !playerOnTile && !isItemTileOccupied) {
                            movingObject.x = x;
                            movingObject.y = y;
                            objects.push(movingObject); // Voeg terug toe aan de lijst
                            movingObject = null; // Stop met verplaatsen
                        }
                    } else { // Anders, pak een object op
                        const objectToMoveIndex = objects.findIndex(o => o.x === x && o.y === y);
                        if (objectToMoveIndex > -1) {
                            movingObject = objects.splice(objectToMoveIndex, 1)[0];
                            closeSecondaryWindows(); // Sluit andere vensters bij het oppakken
                            isBuildObjectFlipped = movingObject.flipped; // Synchroniseer de rotatie-status
                        }
                    }
                    break;
                case 'delete':
                    const objectToDeleteIndex = objects.findIndex(o => o.x === x && o.y === y);
                    if (objectToDeleteIndex > -1) {
                        objects.splice(objectToDeleteIndex, 1);
                    } else if (hoverTarget?.type === 'wall') {
                        const wallObjectToDeleteIndex = wallObjects.findIndex(wo => wo.wallId === hoverTarget.id);
                        if (wallObjectToDeleteIndex > -1) {
                            wallObjects.splice(wallObjectToDeleteIndex, 1);
                        }
                    } else {
                        const itemToDeleteIndex = items.findIndex(item => Math.floor(item.x) === x && Math.floor(item.y) === y);
                        if (itemToDeleteIndex > -1) {
                            items.splice(itemToDeleteIndex, 1);
                        }
                    }
                    break;
            }
        } else if (activeBuildCategory === 'kleur') {
            // --- Kleur Tool Logica ---
            if (hoverTarget) {
                if (colorTool === 'brush') {
                    if (hoverTarget.type === 'tile') {
                        const tileKey = `${hoverTarget.id.x},${hoverTarget.id.y}`;
                        tileColors[tileKey] = selectedColor;
                    } else if (hoverTarget.type === 'wall') {
                        wallColors[hoverTarget.id] = selectedColor;
                    }
                } else if (colorTool === 'bucket') {
                    const startNode = hoverTarget;

                    const getTargetColor = (node) => {
                        if (node.type === 'tile') {
                            return tileColors[`${node.id.x},${node.id.y}`] || '#444';
                        }
                        const defaultColor = node.id.startsWith('top') ? '#555' : '#666';
                        return wallColors[node.id] || defaultColor;
                    };

                    const targetColor = getTargetColor(startNode);

                    if (targetColor === selectedColor) return; // Voorkom oneindige loops

                    const queue = [startNode];
                    const visited = new Set();
                    visited.add(JSON.stringify(startNode.id)); // Gebruik JSON.stringify voor unieke keys

                    while (queue.length > 0) {
                        const current = queue.shift();

                        // Kleur het huidige element
                        if (current.type === 'tile') {
                            tileColors[`${current.id.x},${current.id.y}`] = selectedColor;
                        } else {
                            wallColors[current.id] = selectedColor;
                        }

                        // Vind buren
                        let neighbors = [];
                        if (current.type === 'tile') {
                            const { x, y } = current.id;
                            neighbors = [
                                { type: 'tile', id: { x: x + 1, y: y } },
                                { type: 'tile', id: { x: x - 1, y: y } },
                                { type: 'tile', id: { x: x, y: y + 1 } },
                                { type: 'tile', id: { x: x, y: y - 1 } }
                            ].filter(n => n.id.x >= 0 && n.id.x < mapW && n.id.y >= 0 && n.id.y < mapH);
                        } else { // Wall
                            const [type, indexStr] = current.id.split('_');
                            const index = parseInt(indexStr);
                            neighbors = [
                                { type: 'wall', id: `${type}_${index + 1}` },
                                { type: 'wall', id: `${type}_${index - 1}` }
                            ].filter(n => {
                                const i = parseInt(n.id.split('_')[1]);
                                const max = (type === 'top') ? mapW : mapH;
                                return i >= 0 && i < max;
                            });
                        }

                        for (const neighbor of neighbors) {
                            const neighborIdStr = JSON.stringify(neighbor.id);
                            if (!visited.has(neighborIdStr)) {
                                visited.add(neighborIdStr);
                                if (getTargetColor(neighbor) === targetColor) {
                                    queue.push(neighbor);
                                }
                            }
                        }
                    }
                }
            }
        }
        return; // Bouwactie afgehandeld, stop verdere uitvoering
    }

    // Als het een klik was (niet een sleep) en niet in bouwmodus, start dan spelerbeweging
    if(e.button === 0 && Math.sqrt(dx*dx + dy*dy) < 5 && !isBuildMode){ // Alleen uitvoeren bij linkermuisknop
        const {x, y} = toTile(e.clientX, e.clientY);
        if(x >= 0 && x < mapW && y >= 0 && y < mapH && !isBlocked(x, y)){
            const startTile = { x: Math.floor(ball.x), y: Math.floor(ball.y) };
            path = findPath(startTile, { x, y });
            highlightedPath = [...path]; // Kopieer het pad voor highlighting

            if(!jumping && path.length > 0){
                jumpStart = { x: ball.x, y: ball.y }; // voet als start
                const next = path.shift();
                jumpEnd = { x: next.x + 0.5, y: next.y + 0.5 }; // voet op midden tegel
                jumpProgress = 0;
                jumping = true;
            }
        }
    }
});

// Reset alle dragging states bij mouseleave
canvas.addEventListener("mouseleave", e => {
    isCameraDragging = false;
    isObjectDragging = false;
    // NIEUW: Reset item dragging state bij mouseleave
    if (isItemDragging && draggedItem) {
        items.push(draggedItemOriginalPos); // Zet item terug op originele plek
        isItemDragging = false;
        draggedItem = null;
        draggedItemOriginalPos = null;
        // Heropen de vensters die open stonden
        if (windowStatesBeforeDrag) {
            if (windowStatesBeforeDrag.chat) document.getElementById('chatLog').style.display = windowStatesBeforeDrag.chat;
            if (windowStatesBeforeDrag.inventory) document.getElementById('inventory').style.display = windowStatesBeforeDrag.inventory;
            if (windowStatesBeforeDrag.build === 'flex') {
                buildBtn.click();
            }
            windowStatesBeforeDrag = null;
        }
    }
});

// Rechtermuisklik om bouwselectie te annuleren
canvas.addEventListener("contextmenu", e => {
    e.preventDefault(); // Voorkom altijd het browser context menu op de canvas

    // Bepaal of het een klik was (geen sleepbeweging)
    const dx = e.clientX - dragStart.x;
    const dy = e.clientY - dragStart.y;
    const isClick = Math.sqrt(dx*dx + dy*dy) < 5 && !isCameraDragging; // Voeg check toe voor camera dragging

    // Voer de annuleer-actie alleen uit als het een 'klik' was en geen 'drag'
    if (isClick) {
        if (isBuildMode && selectedBuildObject) {
            selectedBuildObject = null;
            const selectedItem = document.querySelector('.build-item.selected');
            if (selectedItem) {
                selectedItem.classList.remove('selected');
                isBuildObjectFlipped = false;
            }
        }
        if (isBuildMode && movingObject) {
            objects.push(movingObject); // Zet het object terug
            movingObject = null;
        }
        // NIEUW: Annuleer item slepen met rechtermuisklik
        if (isItemDragging && draggedItem) {
            items.push(draggedItemOriginalPos); // Zet item terug
            isItemDragging = false;
            draggedItem = null;
            draggedItemOriginalPos = null;
            // Heropen de vensters die open stonden
            if (windowStatesBeforeDrag) {
                if (windowStatesBeforeDrag.chat) document.getElementById('chatLog').style.display = windowStatesBeforeDrag.chat;
                if (windowStatesBeforeDrag.inventory) document.getElementById('inventory').style.display = windowStatesBeforeDrag.inventory;
                if (windowStatesBeforeDrag.build === 'flex') {
                    buildBtn.click();
                }
                windowStatesBeforeDrag = null;
            }
        }
    }
});


// Zoom knoppen
document.getElementById("zoomIn").addEventListener("click", ()=> {
    if (currentZoomIndex < zoomLevels.length - 1) {
        currentZoomIndex++;
        scale = zoomLevels[currentZoomIndex];
    }
});
document.getElementById("zoomOut").addEventListener("click", ()=> {
    if (currentZoomIndex > 0) {
        currentZoomIndex--;
        scale = zoomLevels[currentZoomIndex];
    }
});

let scaleTarget = 1; // Definieer scaleTarget buiten de center knop

// Center knop
document.getElementById("centerCam").addEventListener("click", ()=>{
    camTargetX = 0;
    camTargetY = 0;
    currentZoomIndex = 2; // Index voor neutraal zoomlevel (1.0)
    scaleTarget = zoomLevels[currentZoomIndex];
    camSmooth = true;
});

function updateCamera(delta){
    if(!camSmooth || delta === 0) return;
    let dx = camTargetX - camX; 
    let dy = camTargetY - camY;
    let distance = Math.sqrt(dx*dx + dy*dy);
    let t = Math.min(0.08 * delta, distance * 0.01);
    camX += dx * t;
    camY += dy * t;

    // Smooth zoom
    let ds = scaleTarget - scale;
    scale += ds * 0.08 * delta;

    if(distance < 0.3 && Math.abs(ds) < 0.01){ 
        camX = camTargetX; 
        camY = camTargetY; 
        scale = scaleTarget; 
        currentZoomIndex = zoomLevels.indexOf(scaleTarget); // Synchroniseer de index
        camSmooth = false; 
    }
}

function updateItems(delta) {
    const friction = 0.92; // Hoe snel items afremmen (dichter bij 1 is minder frictie)

    items.forEach(item => {
        // Sla over als het item wordt versleept
        if (item === draggedItem) return;

        // Pas snelheid toe op positie
        item.x += item.vx * delta;
        item.y += item.vy * delta;

        // Pas frictie toe op snelheid
        item.vx *= friction;
        item.vy *= friction;

        // Stop beweging als de snelheid heel laag is om eindeloos glijden te voorkomen
        if (Math.abs(item.vx) < 0.001) item.vx = 0;
        if (Math.abs(item.vy) < 0.001) item.vy = 0;

        // Simpele muur-collision
        if (item.x < 0.5) { item.x = 0.5; item.vx *= -0.5; }
        if (item.x > mapW - 0.5) { item.x = mapW - 0.5; item.vx *= -0.5; }
        if (item.y < 0.5) { item.y = 0.5; item.vy *= -0.5; }
        if (item.y > mapH - 0.5) { item.y = mapH - 0.5; item.vy *= -0.5; }
    });
}

function updateBall(delta) {
    // Snelheid van de sprong per seconde
    const jumpSpeed = 3; // 3 tiles per second


    if(!jumping && path.length > 0){
        // start van midden van tegel horizontaal, onderkant verticaal
        jumpStart = { 
            x: Math.floor(ball.x) + 0.5, 
            y: Math.floor(ball.y) + 0.5 // onderkant op tegel
        };
        const next = path.shift();
        jumpEnd = { 
            x: next.x + 0.5, 
            y: next.y + 0.5 
        };
        jumpProgress = 0;
        jumping = true;
    }

    if(jumping){
        jumpProgress += jumpSpeed / 60 * delta; // /60 omdat de oude snelheid 0.05 was (1/20)
        if(jumpProgress >= 1){
            jumpProgress = 1;
            ball.x = jumpEnd.x;
            ball.y = jumpEnd.y;
            jumping = false;
            hopOffset = 0;
            // Als het pad leeg is, maak de highlight leeg
            if (path.length === 0) {
                highlightedPath = [];
            }

            if(path.length > 0){
                jumpStart = { x: ball.x, y: ball.y };
                const next = path.shift();
                jumpEnd = { x: next.x + 0.5, y: next.y + 0.5 };
                jumpProgress = 0;
                jumping = true;
            }
        } else {
            // interpolatie
            ball.x = jumpStart.x + (jumpEnd.x - jumpStart.x) * jumpProgress;
            ball.y = jumpStart.y + (jumpEnd.y - jumpStart.y) * jumpProgress;
            hopOffset = jumpHeight * 4 * jumpProgress * (1 - jumpProgress);
        }
    } else hopOffset = 0;

    // Speler-item collision
    items.forEach(item => {
        // Sla over als het item wordt versleept
        if (item === draggedItem) return;

        const dx = item.x - ball.x;
        const dy = item.y - ball.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        const minDistance = 0.6; // Hoe dichtbij de speler moet zijn om te duwen

        if (distance < minDistance) {
            const pushForce = 0.05 / item.mass; // Kracht van de duw, beÃ¯nvloed door massa
            const angle = Math.atan2(dy, dx);
            item.vx += Math.cos(angle) * pushForce;
            item.vy += Math.sin(angle) * pushForce;
        }
    });
}

let isDraggingChat = false;
let dragStartChat = {x:0, y:0};
let chatStartPos = {x:0, y:0};

chatLog.addEventListener("mousedown", (e) => {
    bringToFront(chatLog);
    isDraggingChat = true;
    dragStartChat = {x: e.clientX, y: e.clientY};
    
    // Voorkom dat de canvas een 'mousedown' event ontvangt als we op een UI-element klikken
    if (e.target.closest('#chatLog')) {
        e.stopPropagation();
    }

    const rect = chatLog.getBoundingClientRect();
    chatStartPos = {x: rect.left, y: rect.top};
    e.preventDefault();
});

window.addEventListener("mousemove", (e) => {
    if (!isDraggingChat) return;

    const dx = e.clientX - dragStartChat.x;
    const dy = e.clientY - dragStartChat.y;

    const newX = chatStartPos.x + dx;
    const newY = chatStartPos.y + dy;

    const rect = chatLog.getBoundingClientRect();

    const minX = 0;
    const minY = 0;
    const maxX = window.innerWidth - rect.width;
    const maxY = window.innerHeight - rect.height;

    chatLog.style.left = Math.max(minX, Math.min(newX, maxX)) + "px";
    chatLog.style.top  = Math.max(minY, Math.min(newY, maxY)) + "px";
});

buildMenu.addEventListener("mousedown", (e) => {
    // Alleen slepen als we op de header klikken
    if (!e.composedPath().includes(document.getElementById('buildMenuHeader'))) return;
    bringToFront(buildMenu);

    // Voorkom dat de canvas een 'mousedown' event ontvangt als we op een UI-element klikken
    if (e.target.closest('#buildMenu')) {
        e.stopPropagation();
    }


    isDraggingBuild = true;
    dragStartBuild = {x: e.clientX, y: e.clientY};
    const rect = buildMenu.getBoundingClientRect();
    buildStartPos = {x: rect.left, y: rect.top};
    e.preventDefault();
});

window.addEventListener("mousemove", (e) => {
    if (!isDraggingBuild) return;

    const dx = e.clientX - dragStartBuild.x;
    const dy = e.clientY - dragStartBuild.y;

    const newX = Math.max(0, Math.min(buildStartPos.x + dx, window.innerWidth - buildMenu.offsetWidth));
    const newY = Math.max(0, Math.min(buildStartPos.y + dy, window.innerHeight - buildMenu.offsetHeight));

    buildMenu.style.left = newX + "px";
    buildMenu.style.top  = newY + "px";
});

inventory.addEventListener("mousedown", (e) => {
    // Alleen slepen als we op de header klikken
    if (!e.composedPath().includes(document.getElementById('inventoryHeader'))) return;
    bringToFront(inventory);

    // Voorkom dat de canvas een 'mousedown' event ontvangt als we op een UI-element klikken
    if (e.target.closest('#inventory')) {
        e.stopPropagation();
    }


    isDraggingInventory = true;
    dragStartInventory = {x: e.clientX, y: e.clientY};
    const rect = inventory.getBoundingClientRect();
    inventoryStartPos = {x: rect.left, y: rect.top};
    e.preventDefault();
});

window.addEventListener("mousemove", (e) => {
    if (!isDraggingInventory) return;

    const dx = e.clientX - dragStartInventory.x;
    const dy = e.clientY - dragStartInventory.y;

    const newX = Math.max(0, Math.min(inventoryStartPos.x + dx, window.innerWidth - inventory.offsetWidth));
    const newY = Math.max(0, Math.min(inventoryStartPos.y + dy, window.innerHeight - inventory.offsetHeight));

    inventory.style.left = newX + "px";
    inventory.style.top  = newY + "px";
});

window.addEventListener("mouseup", (e) => {
    // Als we een object aan het slepen waren, handel dat eerst af.
    if (isObjectDragging) {
        // De logica hiervoor is verplaatst naar de globale mouseup listener
        // om te garanderen dat het altijd werkt.
    }

    // Stop met het slepen van UI-elementen
    isDraggingChat = false;
    isDraggingBuild = false;
    isDraggingInventory = false;

    // Stop met het slepen van de camera (rechtermuisknop)
    if (e.button === 2) {
        isCameraDragging = false;
    }

    // Handel het loslaten van een gesleept object af, ongeacht waar de muis is
    if (isObjectDragging && e.button === 0) { // Alleen voor linkermuisknop
        const {x, y} = toTile(e.clientX, e.clientY);
        const playerOnTile = Math.floor(ball.x) === x && Math.floor(ball.y) === y;
        // Check voor 'isBlocked' zonder het object dat we slepen mee te rekenen
        const isOccupied = objects.some(o => o.x === x && o.y === y);
        const isValidPlacement = x >= 0 && x < mapW && y >= 0 && y < mapH && !isOccupied && !playerOnTile;

        if (isValidPlacement) {
            draggedObject.x = x;
            draggedObject.y = y;
        } else {
            // Plaats terug op de originele positie als de nieuwe plek ongeldig is
            draggedObject.x = draggedObjectOriginalPos.x;
            draggedObject.y = draggedObjectOriginalPos.y;
        }
        objects.push(draggedObject); // Voeg het object (terug) toe aan de wereld

        // Reset alle sleep-gerelateerde variabelen
        draggedObject = null;
        draggedObjectOriginalPos = null;
        isObjectDragging = false;

        // Start het soepel terugkeren van de camera als deze was meebewogen
        if (camOriginalPos) {
            camTargetX = camOriginalPos.x;
            camTargetY = camOriginalPos.y;
            camSmooth = true;
            camOriginalPos = null;
        }

        // Heropen de vensters die open stonden
        if (windowStatesBeforeDrag) {
            if (windowStatesBeforeDrag.chat) document.getElementById('chatLog').style.display = windowStatesBeforeDrag.chat;
            if (windowStatesBeforeDrag.inventory) document.getElementById('inventory').style.display = windowStatesBeforeDrag.inventory;
            // Voor het bouwmenu moeten we de 'isBuildMode' vlag correct zetten
            if (windowStatesBeforeDrag.build === 'flex') {
                buildBtn.click(); // Simuleer een klik om de bouwmodus correct te heractiveren
            }
            windowStatesBeforeDrag = null; // Reset de opgeslagen staat
        }
        return; // Belangrijk: stop verdere uitvoering om te voorkomen dat de speler gaat lopen.
    }

    // Stop camera slepen met rechtermuisknop
    if (isCameraDragging && e.button === 2) {
        isCameraDragging = false;
    }
});



// Initieel renderen van de bouw-items (ook al is het menu verborgen)
renderBuildItems();

setInterval(() => {
    const active = chatMessages
        .filter(m => Date.now() - m.time < m.duration)
        .sort((a, b) => a.time - b.time);

    if (active.length >= 5) {
        const oldest = active[0];
        const remaining =
            Math.max(
                0,
                Math.ceil((oldest.duration - (Date.now() - oldest.time)) / 1000)
            );

        chatInput.disabled = true;
        chatInput.value = "";
        chatInput.placeholder = `Even wachten (${remaining}s)`;
    } else {
        chatInput.disabled = false;
        chatInput.placeholder = "Typ hier je bericht...";
        chatInput.style.color = "#000";
    }
}, 250);

function loop(time) {
    // Bereken delta in fractie van een 60fps frame voor compatibiliteit
    const deltaTime = time - lastTime;
    const delta = deltaTime / (1000 / 60); // delta is ~1.0 bij 60fps
    lastTime = time;

    ctx.setTransform(1,0,0,1,0,0);

    // --- Camera pan tijdens slepen van object ---
    if (isObjectDragging) { // Gebruik de nieuwe variabele
        const panZone = 100; // De grootte van de zone aan de randen van het scherm
        const panSpeed = 5 * delta;

        if (mousePos.x < panZone) camX += panSpeed;
        if (mousePos.x > window.innerWidth - panZone) camX -= panSpeed;
        if (mousePos.y < panZone) camY += panSpeed;
        if (mousePos.y > window.innerHeight - panZone) camY -= panSpeed;

        // Update de target voor als we stoppen met slepen
        camOriginalPos.x = camX;
        camOriginalPos.y = camY;
    }
    // --- Einde camera pan ---

    ctx.clearRect(0,0,canvas.width,canvas.height);

    ctx.setTransform(
        scale, 0, 0, scale,
        canvas.width / 2 + camX,
        canvas.height / 4 + camY
    );

    drawTiles();
    drawTopWall();
    drawLeftWall();
    updateItems(delta); // Update de positie en snelheid van de items
    updateBall(delta); // delta meegeven

    // --- Dieptegesorteerde renderlijst ---
    const renderList = [];
    let playerAdded = false;
    const playerTileX = Math.floor(ball.x);
    const playerTileY = Math.floor(ball.y);

    // Voeg objecten toe aan de renderlijst
    objects.forEach(obj => {
        // De 3 tegels achter het object waar de speler "achter" het object zou staan
        let behindTiles = [
            { x: obj.x, y: obj.y - 1 },     // Direct achter (boven)
            { x: obj.x - 1, y: obj.y },     // Links-achter
            { x: obj.x - 1, y: obj.y - 1 }  // Links-boven-achter
        ];

        // Voor hoge objecten, voeg een extra rij tegels toe
        if (obj.height === 2) {
            behindTiles.push({ x: obj.x - 1, y: obj.y - 2 }); // Twee boven, een links (209)
            behindTiles.push({ x: obj.x - 2, y: obj.y - 2 }); // Twee boven, twee links (208)
            behindTiles.push({ x: obj.x - 2, y: obj.y - 1 }); // Een boven, twee links (233)
        }

        const isPlayerBehind = behindTiles.some(t => playerTileX === t.x && playerTileY === t.y);

        // Check of een item achter het object staat
        const isItemBehind = items.some(item => {
            const itemTileX = Math.floor(item.x);
            const itemTileY = Math.floor(item.y);
            return behindTiles.some(t => itemTileX === t.x && itemTileY === t.y);
        });

        // Voeg het object toe aan de lijst
        renderList.push({
            type: 'object',
            x: obj.x,
            y: obj.y,
            draw: () => {
                const { sx, sy } = toScreen(obj.x, obj.y);
                // Maak object transparant als de speler erachter staat
                ctx.globalAlpha = (isPlayerBehind || isItemBehind) ? 0.5 : 1;

                const isTall = obj.height === 2;
                let img = isTall ? objectImg96 : objectImg;
                const imgHeight = isTall ? 96 : 64;
                let finalImg = img;

                if (obj.moveable) {
                    finalImg = moveableObjectImg;
                }

                if (obj.flipped) {
                    ctx.save();
                    ctx.scale(-1, 1);
                }

                ctx.drawImage(
                    finalImg,
                    obj.flipped ? -sx - 32 : sx - 32, // horizontaal centreren
                    sy - imgHeight + tileH, // verticale correctie
                    64,
                    imgHeight
                );
                ctx.globalAlpha = 1;
                if (obj.flipped) {
                    ctx.restore();
                }
            }
        });
    });

    // Voeg items toe aan de renderlijst
    items.forEach(item => {
        // Sla over als het item wordt versleept, want die wordt apart getekend
        if (item === draggedItem) return;

        renderList.push({
            type: 'item',
            x: Math.floor(item.x), // Gebruik de tegelcoÃ¶rdinaat voor sortering
            y: Math.floor(item.y), // Gebruik de tegelcoÃ¶rdinaat voor sortering
            draw: () => {
                const { sx, sy } = toScreen(item.x, item.y);
                ctx.drawImage(
                    item.image,
                    sx - item.image.width / 2, // Horizontaal centreren
                    sy - item.image.height / 2 // Verticaal centreren op de tegel
                );
            }
        });
    });

    // NIEUW: Voeg het versleepte item toe aan de renderlijst voor correcte diepte
    if (isItemDragging && draggedItem) {
        const sortX = draggedItem.x;
        const sortY = draggedItem.y;

        renderList.push({
            type: 'draggedItemPreview',
            x: sortX,
            y: sortY,
            draw: () => {
                const { sx, sy } = toScreen(draggedItem.x, draggedItem.y);
                ctx.globalAlpha = 0.7; // Maak de preview half-transparant
                ctx.drawImage(
                    draggedItem.image,
                    sx - draggedItem.image.width / 2, // Horizontaal centreren
                    sy - draggedItem.image.height / 2 // Verticaal centreren
                );
                ctx.globalAlpha = 1.0; // Reset alpha
            }
        });
    }

    // Voeg de speler toe aan de renderlijst
    renderList.push({
        type: 'player',
        x: playerTileX, // Gebruik de tegelcoÃ¶rdinaat voor correcte sortering
        y: playerTileY, // Gebruik de tegelcoÃ¶rdinaat voor correcte sortering
        draw: drawBall
    });

    // Voeg de bouw-preview toe aan de renderlijst voor correcte diepte
    const objectToPreview = (selectedBuildObject?.placement === 'floor' && selectedBuildObject) || movingObject || draggedObject;
    if (objectToPreview && hoverCell) {
        const playerOnTile = Math.floor(ball.x) === hoverCell.x && Math.floor(ball.y) === hoverCell.y; // Definieer playerOnTile hier
        const isOccupied = isBlocked(hoverCell.x, hoverCell.y);
        const isItemTileOccupied = isItemOccupied(hoverCell.x, hoverCell.y);
        const isValidPlacement = !isOccupied && !playerOnTile && !isItemTileOccupied;

        if (isValidPlacement) {
            renderList.push({
                type: 'preview',
                x: hoverCell.x,
                y: hoverCell.y,
                draw: () => {
                    const { sx, sy } = toScreen(hoverCell.x, hoverCell.y);
                    const isTall = objectToPreview.height === 2;
                    const img = isTall ? objectImg96 : objectImg;
                    const imgHeight = isTall ? 96 : 64;
                    let finalImg = img;

                    // Gebruik de juiste afbeelding voor de preview
                    if (objectToPreview.moveable) {
                        finalImg = moveableObjectImg;
                    }

                    ctx.globalAlpha = 0.7; // Maak de preview half-transparant
                    if (isBuildObjectFlipped) {
                        ctx.save();
                        ctx.scale(-1, 1);
                    }
                    ctx.drawImage(finalImg, isBuildObjectFlipped ? -sx - 32 : sx - 32, sy - imgHeight + tileH, 64, imgHeight);
                    
                    if (isBuildObjectFlipped) {
                        ctx.restore();
                    }

                    ctx.globalAlpha = 1; // Reset alpha
                }
            });
        }
    }
    
    // Sorteer op x+y voor isometrische diepte
    renderList.sort((a,b) => (a.x + a.y) - (b.x + b.y));

    // Alles tekenen
    for (let item of renderList) {
        item.draw();
    }
    // --- Einde renderlijst ---

    drawChatBallon();
    updateCamera(delta); // delta meegeven

    requestAnimationFrame(loop);
}

requestAnimationFrame(loop); // Start de loop

})(); // Einde van de IIFE

</script>
</body>
</html>
